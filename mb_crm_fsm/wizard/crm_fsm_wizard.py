from odoo import models, fields, api, _ 
from odoo.exceptions import ValidationError

class CRMFSMWizard(models.TransientModel):
    _name = 'crm.fsm.wizard'

    lead_id = fields.Many2one(comodel_name='crm.lead', required="1")

    project_template_id = fields.Many2one(comodel_name='project.project', string="Project Template",required="1")
    company_id = fields.Many2one('res.company', related="lead_id.company_id")



    ###########################################
    # Service : Project and task generation
    ###########################################

    def _convert_qty_company_hours(self, dest_company):
        return self.product_uom_qty

    def _timesheet_create_project_prepare_values(self):
        """Generate project values"""
        # account = self.order_id.analytic_account_id
        # if not account:
        #     self.order_id._create_analytic_account(prefix=self.product_id.default_code or None)
        #     account = self.order_id.analytic_account_id

        # create the project or duplicate one
        return {
            'name': '%s - %s' % (self.lead_id.partner_id.name, self.lead_id.name) if self.lead_id.partner_id else self.lead_id.name,
            'analytic_account_id': False,
            'partner_id': self.lead_id.partner_id.id,
            # 'sale_line_id': self.id,
            'active': True,
            'company_id': self.company_id.id,
            'lead_id': self.lead_id.id,

        }

    def _timesheet_create_project(self):
        """ Generate project for the given so line, and link it.
            :param project: record of project.project in which the task should be created
            :return task: record of the created task
        """
        self.ensure_one()
        values = self._timesheet_create_project_prepare_values()
        if self.project_template_id:
            project = self.project_template_id.copy(values)
            project.tasks.write({
                'lead_id': self.id,
                'partner_id': self.lead_id.partner_id.id,
                'email_from': self.lead_id.partner_id.email,
            })
            # duplicating a project doesn't set the SO on sub-tasks
            project.tasks.filtered(lambda task: task.parent_id != False).write({
                'sale_line_id': False,
                'sale_order_id': False,
                'lead_id': self.lead_id.id
            })
        else:
            project = self.env['project.project'].create(values)

        # Avoid new tasks to go to 'Undefined Stage'
        if not project.type_ids:
            project.type_ids = self.env['project.task.type'].create({'name': _('New')})

        # link project as generated by current so line
        # self.lead_id.write({'project_id': project.id})
        return project

    def _timesheet_create_task_prepare_values(self, project):
        self.ensure_one()
        sale_line_name_parts = self.lead_id.name.split('\n')
        title = sale_line_name_parts[0] or self.product_id.name
        description = '<br/>'.join(sale_line_name_parts[1:])
        return {
            'name': title if project.sale_line_id else '%s: %s' % (self.lead_id.name or '', title),
            'partner_id': self.lead_id.partner_id.id,
            'email_from': self.lead_id.partner_id.email,
            'description': description,
            'project_id': project.id,
            'lead_id': self.lead_id.id,
            'company_id': project.company_id.id,
            'user_ids': False,  # force non assigned task, as created as sudo()
        }

    def _timesheet_create_task(self, project):
        """ Generate task for the given so line, and link it.
            :param project: record of project.project in which the task should be created
            :return task: record of the created task
        """
        values = self._timesheet_create_task_prepare_values(project)
        task = self.env['project.task'].sudo().create(values)
        # self.write({'task_id': task.id})
        # post message on task
        # task_msg = _("This task has been created from: <a href=# data-oe-model=sale.order data-oe-id=%d>%s</a> (%s)") % (self.order_id.id, self.order_id.name, self.product_id.name)
        # task.message_post(body=task_msg)
        return task


    def create_fsm(self):
        """ For Lead, create the Project from selected template."""
        
        if not self.lead_id.partner_id:
            raise ValidationError(_('A customer should be set on the Opportunity to create Field Service Project.'))

        project = self._timesheet_create_project()
        self._timesheet_create_task(project=project)
        # so_line_task_global_project = self.filtered(lambda sol: sol.is_service and sol.product_id.service_tracking == 'task_global_project')
        # so_line_new_project = self.filtered(lambda sol: sol.is_service and sol.product_id.service_tracking in ['project_only', 'task_in_project'])

        # # search so lines from SO of current so lines having their project generated, in order to check if the current one can
        # # create its own project, or reuse the one of its order.
        # map_so_project = {}
        # if so_line_new_project:
        #     order_ids = self.mapped('order_id').ids
        #     so_lines_with_project = self.search([('order_id', 'in', order_ids), ('project_id', '!=', False), ('product_id.service_tracking', 'in', ['project_only', 'task_in_project']), ('product_id.project_template_id', '=', False)])
        #     map_so_project = {sol.order_id.id: sol.project_id for sol in so_lines_with_project}
        #     so_lines_with_project_templates = self.search([('order_id', 'in', order_ids), ('project_id', '!=', False), ('product_id.service_tracking', 'in', ['project_only', 'task_in_project']), ('product_id.project_template_id', '!=', False)])
        #     map_so_project_templates = {(sol.order_id.id, sol.product_id.project_template_id.id): sol.project_id for sol in so_lines_with_project_templates}

        # # search the global project of current SO lines, in which create their task
        # map_sol_project = {}
        # if so_line_task_global_project:
        #     map_sol_project = {sol.id: sol.product_id.with_company(sol.company_id).project_id for sol in so_line_task_global_project}

        # def _can_create_project(sol):
        #     if not sol.project_id:
        #         if sol.product_id.project_template_id:
        #             return (sol.order_id.id, sol.product_id.project_template_id.id) not in map_so_project_templates
        #         elif sol.order_id.id not in map_so_project:
        #             return True
        #     return False

        # def _determine_project(so_line):
        #     """Determine the project for this sale order line.
        #     Rules are different based on the service_tracking:

        #     - 'project_only': the project_id can only come from the sale order line itself
        #     - 'task_in_project': the project_id comes from the sale order line only if no project_id was configured
        #       on the parent sale order"""

        #     if so_line.product_id.service_tracking == 'project_only':
        #         return so_line.project_id
        #     elif so_line.product_id.service_tracking == 'task_in_project':
        #         return so_line.order_id.project_id or so_line.project_id

        #     return False

        # # task_global_project: create task in global project
        # for so_line in so_line_task_global_project:
        #     if not so_line.task_id:
        #         if map_sol_project.get(so_line.id) and so_line.product_uom_qty > 0:
        #             so_line._timesheet_create_task(project=map_sol_project[so_line.id])

        # # project_only, task_in_project: create a new project, based or not on a template (1 per SO). May be create a task too.
        # # if 'task_in_project' and project_id configured on SO, use that one instead
        # for so_line in so_line_new_project:
        #     project = _determine_project(so_line)
        #     if not project and _can_create_project(so_line):
        #         project = so_line._timesheet_create_project()
        #         if so_line.product_id.project_template_id:
        #             map_so_project_templates[(so_line.order_id.id, so_line.product_id.project_template_id.id)] = project
        #         else:
        #             map_so_project[so_line.order_id.id] = project
        #     elif not project:
        #         # Attach subsequent SO lines to the created project
        #         so_line.project_id = (
        #             map_so_project_templates.get((so_line.order_id.id, so_line.product_id.project_template_id.id))
        #             or map_so_project.get(so_line.order_id.id)
        #         )
        #     if so_line.product_id.service_tracking == 'task_in_project':
        #         if not project:
        #             if so_line.product_id.project_template_id:
        #                 project = map_so_project_templates[(so_line.order_id.id, so_line.product_id.project_template_id.id)]
        #             else:
        #                 project = map_so_project[so_line.order_id.id]
        #         if not so_line.task_id:
        #             so_line._timesheet_create_task(project=project)

    # def _prepare_invoice_line(self, **optional_values):
    #     """
    #         If the sale order line isn't linked to a sale order which already have a default analytic account,
    #         this method allows to retrieve the analytic account which is linked to project or task directly linked
    #         to this sale order line, or the analytic account of the project which uses this sale order line, if it exists.
    #     """
    #     values = super(SaleOrderLine, self)._prepare_invoice_line(**optional_values)
    #     if not values.get('analytic_account_id'):
    #         task_analytic_account = self.task_id._get_task_analytic_account_id() if self.task_id else False
    #         if task_analytic_account:
    #             values['analytic_account_id'] = task_analytic_account.id
    #         elif self.project_id.analytic_account_id:
    #             values['analytic_account_id'] = self.project_id.analytic_account_id.id
    #         elif self.is_service and not self.is_expense:
    #             task_analytic_account_id = self.env['project.task'].read_group([
    #                 ('sale_line_id', '=', self.id),
    #                 ('analytic_account_id', '!=', False),
    #             ], ['analytic_account_id'], ['analytic_account_id'])
    #             project_analytic_account_id = self.env['project.project'].read_group([
    #                 ('analytic_account_id', '!=', False),
    #                 '|',
    #                     ('sale_line_id', '=', self.id),
    #                     '&',
    #                         ('tasks.sale_line_id', '=', self.id),
    #                         ('tasks.analytic_account_id', '=', False)
    #             ], ['analytic_account_id'], ['analytic_account_id'])
    #             analytic_account_ids = {rec['analytic_account_id'][0] for rec in (task_analytic_account_id + project_analytic_account_id)}
    #             if len(analytic_account_ids) == 1:
    #                 values['analytic_account_id'] = analytic_account_ids.pop()
    #     if self.task_id.analytic_tag_ids:
    #         values['analytic_tag_ids'] += [Command.link(tag_id.id) for tag_id in self.task_id.analytic_tag_ids]
    #     elif self.is_service and not self.is_expense:
    #         tag_ids = self.env['account.analytic.tag'].search([
    #             ('task_ids.sale_line_id', '=', self.id)
    #         ])
    #         values['analytic_tag_ids'] += [Command.link(tag_id.id) for tag_id in tag_ids]
    #     return values

